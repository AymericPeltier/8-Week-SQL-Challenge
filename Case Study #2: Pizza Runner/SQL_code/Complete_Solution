-------------------------------------------------
-- Data with Danny - 8 Week Challenge (Week 2) --
-- https://8weeksqlchallenge.com/case-study-2/ --
-------------------------------------------------
-- Done with PostgreSQL
-- By Aymeric Peltier
-- Date: 19/05/2021


-- **Schema (PostgreSQL v13)**
DROP TABLE IF EXISTS runners;
CREATE TABLE runners (
    "runner_id" INTEGER,
    "registration_date" DATE
);
INSERT INTO runners ("runner_id", "registration_date")
VALUES (1, '2021-01-01'),
    (2, '2021-01-03'),
    (3, '2021-01-08'),
    (4, '2021-01-15');
DROP TABLE IF EXISTS customer_orders;
CREATE TABLE customer_orders (
    "order_id" INTEGER,
    "customer_id" INTEGER,
    "pizza_id" INTEGER,
    "exclusions" VARCHAR(4),
    "extras" VARCHAR(4),
    "order_time" TIMESTAMP
);
INSERT INTO customer_orders (
        "order_id",
        "customer_id",
        "pizza_id",
        "exclusions",
        "extras",
        "order_time"
    )
VALUES ('1', '101', '1', '', '', '2020-01-01 18:05:02'),
    ('2', '101', '1', '', '', '2020-01-01 19:00:52'),
    ('3', '102', '1', '', '', '2020-01-02 12:51:23'),
    ('3', '102', '2', '', NULL, '2020-01-02 12:51:23'),
    ('4', '103', '1', '4', '', '2020-01-04 13:23:46'),
    ('4', '103', '1', '4', '', '2020-01-04 13:23:46'),
    ('4', '103', '2', '4', '', '2020-01-04 13:23:46'),
    (
        '5',
        '104',
        '1',
        'null',
        '1',
        '2020-01-08 21:00:29'
    ),
    (
        '6',
        '101',
        '2',
        'null',
        'null',
        '2020-01-08 21:03:13'
    ),
    (
        '7',
        '105',
        '2',
        'null',
        '1',
        '2020-01-08 21:20:29'
    ),
    (
        '8',
        '102',
        '1',
        'null',
        'null',
        '2020-01-09 23:54:33'
    ),
    (
        '9',
        '103',
        '1',
        '4',
        '1, 5',
        '2020-01-10 11:22:59'
    ),
    (
        '10',
        '104',
        '1',
        'null',
        'null',
        '2020-01-11 18:34:49'
    ),
    (
        '10',
        '104',
        '1',
        '2, 6',
        '1, 4',
        '2020-01-11 18:34:49'
    );
DROP TABLE IF EXISTS runner_orders;
CREATE TABLE runner_orders (
    "order_id" INTEGER,
    "runner_id" INTEGER,
    "pickup_time" VARCHAR(19),
    "distance" VARCHAR(7),
    "duration" VARCHAR(10),
    "cancellation" VARCHAR(23)
);
INSERT INTO runner_orders (
        "order_id",
        "runner_id",
        "pickup_time",
        "distance",
        "duration",
        "cancellation"
    )
VALUES (
        '1',
        '1',
        '2020-01-01 18:15:34',
        '20km',
        '32 minutes',
        ''
    ),
    (
        '2',
        '1',
        '2020-01-01 19:10:54',
        '20km',
        '27 minutes',
        ''
    ),
    (
        '3',
        '1',
        '2020-01-02 00:12:37',
        '13.4km',
        '20 mins',
        NULL
    ),
    (
        '4',
        '2',
        '2020-01-04 13:53:03',
        '23.4',
        '40',
        NULL
    ),
    (
        '5',
        '3',
        '2020-01-08 21:10:57',
        '10',
        '15',
        NULL
    ),
    (
        '6',
        '3',
        'null',
        'null',
        'null',
        'Restaurant Cancellation'
    ),
    (
        '7',
        '2',
        '2020-01-08 21:30:45',
        '25km',
        '25mins',
        'null'
    ),
    (
        '8',
        '2',
        '2020-01-10 00:15:02',
        '23.4 km',
        '15 minute',
        'null'
    ),
    (
        '9',
        '2',
        'null',
        'null',
        'null',
        'Customer Cancellation'
    ),
    (
        '10',
        '1',
        '2020-01-11 18:50:20',
        '10km',
        '10minutes',
        'null'
    );
DROP TABLE IF EXISTS pizza_names;
CREATE TABLE pizza_names (
    "pizza_id" INTEGER,
    "pizza_name" TEXT
);
INSERT INTO pizza_names ("pizza_id", "pizza_name")
VALUES (1, 'Meatlovers'),
    (2, 'Vegetarian');
DROP TABLE IF EXISTS pizza_recipes;
CREATE TABLE pizza_recipes (
    "pizza_id" INTEGER,
    "toppings" TEXT
);
INSERT INTO pizza_recipes ("pizza_id", "toppings")
VALUES (1, '1, 2, 3, 4, 5, 6, 8, 10'),
    (2, '4, 6, 7, 9, 11, 12');
DROP TABLE IF EXISTS pizza_toppings;
CREATE TABLE pizza_toppings (
    "topping_id" INTEGER,
    "topping_name" TEXT
);
INSERT INTO pizza_toppings ("topping_id", "topping_name")
VALUES (1, 'Bacon'),
    (2, 'BBQ Sauce'),
    (3, 'Beef'),
    (4, 'Cheese'),
    (5, 'Chicken'),
    (6, 'Mushrooms'),
    (7, 'Onions'),
    (8, 'Pepperoni'),
    (9, 'Peppers'),
    (10, 'Salami'),
    (11, 'Tomatoes'),
    (12, 'Tomato Sauce');
-----------------------------------------------
--PART 1: FIXING THE TABLES
-- First: customer_orders
--- Creating a view ---
DROP TABLE IF EXISTS customer_orders_cleaned;
CREATE TEMP TABLE customer_orders_cleaned AS WITH first_layer AS (
    SELECT order_id,
        customer_id,
        pizza_id,
        CASE
            WHEN exclusions = '' THEN NULL
            WHEN exclusions = 'null' THEN NULL
            ELSE exclusions
        END as exclusions,
        CASE
            WHEN extras = '' THEN NULL
            WHEN extras = 'null' THEN NULL
            ELSE extras
        END as extras,
        order_time
    FROM customer_orders
)
SELECT ROW_NUMBER() OVER (
        -- We are adding a row_number rank to deal with orders having multiple times the same pizza in it
        ORDER BY order_id,
            pizza_id
    ) AS row_number_order,
    order_id,
    customer_id,
    pizza_id,
    exclusions,
    extras,
    order_time
FROM first_layer;

-----------------------------------------------
-- Second: runner_orders:
DROP TABLE IF EXISTS runner_orders_cleaned;
CREATE TEMP TABLE runner_orders_cleaned AS WITH first_layer AS (
    SELECT order_id,
        runner_id,
        CAST(
            CASE
                WHEN pickup_time = 'null' THEN NULL
                ELSE pickup_time
            END AS timestamp
        ) AS pickup_time,
        CASE
            WHEN distance = '' THEN NULL
            WHEN distance = 'null' THEN NULL
            ELSE distance
        END as distance,
        CASE
            WHEN duration = '' THEN NULL
            WHEN duration = 'null' THEN NULL
            ELSE duration
        END as duration,
        CASE
            WHEN cancellation = '' THEN NULL
            WHEN cancellation = 'null' THEN NULL
            ELSE cancellation
        END as cancellation
    FROM runner_orders
)
SELECT order_id,
    runner_id,
    CASE
        WHEN order_id = '3' THEN (pickup_time + INTERVAL '13 hour')
        ELSE pickup_time
    END AS pickup_time,
    CAST(
        regexp_replace(distance, '[a-z]+', '') AS DECIMAL(5, 2)
    ) AS distance,
    CAST(regexp_replace(duration, '[a-z]+', '') AS INT) AS duration,
    cancellation
FROM first_layer;
-----------------------------------------------------------
--PART 1: PIZZA METRICS !
--1) How many pizzas were ordered?
--2) How many unique customer orders were made?
--3) How many successful orders were delivered by each runner?
--4) How many of each type of pizza was delivered?
--5) How many Vegetarian and Meatlovers were ordered by each customer?
--6) What was the maximum number of pizzas delivered in a single order?
--7) For each customer, how many delivered pizzas had at least 1 change and how many had no changes?
--8) How many pizzas were delivered that had both exclusions and extras?
--9) What was the total volume of pizzas ordered for each hour of the day?
--10) What was the volume of orders for each day of the week?
--1) How many pizzas were ordered?

SELECT COUNT(pizza_id) AS number_of_pizza_ordered
FROM customer_orders_cleaned; 

--2) How many unique customer orders were made?
SELECT COUNT(DISTINCT order_id) AS distinct_orders
FROM customer_orders_cleaned; 

--3) How many successful orders were delivered by each runner?
SELECT COUNT(order_id) AS distinct_orders
FROM runner_orders_cleaned
WHERE cancellation IS NULL; 

--4) How many of each type of pizza was delivered?
SELECT C.pizza_id,
    COUNT(C.pizza_id) as pizza_delivered
FROM customer_orders_cleaned AS C
    LEFT JOIN runner_orders_cleaned AS R ON C.order_id = R.order_id
WHERE R.cancellation IS NULL
GROUP BY pizza_id; 

--5) How many Vegetarian and Meatlovers were ordered by each customer?
SELECT customer_id,
    SUM(
        CASE
            WHEN pizza_id = 1 THEN 1
            ELSE 0
        END
    ) as meatlovers,
    SUM(
        CASE
            WHEN pizza_id = 2 THEN 1
            ELSE 0
        END
    ) as vegetarians
FROM customer_orders_cleaned
GROUP BY customer_id
ORDER BY customer_id; 

--6) What was the maximum number of pizzas delivered in a single order?
SELECT order_id,
    COUNT(pizza_id) as pizzas_delivered
FROM customer_orders_cleaned
GROUP BY order_id
ORDER BY pizzas_delivered DESC; 

--7) For each customer, how many delivered pizzas had at least 1 change and how many had no changes?
SELECT customer_id,
    SUM(
        CASE
            WHEN (
                exclusions IS NOT NULL
                OR extras IS NOT NULL
            ) THEN 1
            ELSE 0
        END
    ) as changes_performed,
    SUM(
        CASE
            WHEN (
                exclusions IS NULL
                AND extras IS NULL
            ) THEN 1
            ELSE 0
        END
    ) as no_changes
FROM customer_orders_cleaned
GROUP BY customer_id
ORDER BY customer_id; 

--8) How many pizzas were delivered that had both exclusions and extras?
SELECT SUM(
        CASE
            WHEN (
                exclusions IS NOT NULL
                AND extras IS NOT NULL
            ) THEN 1
            ELSE 0
        END
    ) as exclusions_and_extra
FROM customer_orders_cleaned; 

--9) What was the total volume of pizzas ordered for each hour of the day?
SELECT extract(
        hour
        from order_time
    ) AS order_hour,
    COUNT(
        extract(
            hour
            from order_time
        )
    ) AS count_pizza_ordered,
    ROUND(
        100 * COUNT(
            extract(
                hour
                from order_time
            )
        ) / SUM(COUNT(*)) OVER (),
        2
    ) AS volume_pizza_ordered
FROM customer_orders_cleaned
GROUP BY order_hour
ORDER BY order_hour; 

--10) What was the volume of orders for each day of the week?
SELECT to_char(order_time, 'Day') AS day_ordered,
    COUNT(to_char(order_time, 'Day')) AS count_pizza_ordered,
    ROUND(
        100 * COUNT(to_char(order_time, 'Day')) / SUM(COUNT(*)) OVER (),
        2
    ) AS volume_pizza_ordered
FROM customer_orders_cleaned
GROUP BY day_ordered
ORDER BY day_ordered; 

--------------------------------------------------------------
--PART 2: Runner and Customer Experience!
--1) How many runners signed up for each 1 week period? (i.e. week starts 2021-01-01)
--2) What was the average time in minutes it took for each runner to arrive at the Pizza Runner HQ to pickup the order?
--3) Is there any relationship between the number of pizzas and how long the order takes to prepare?
--4) What was the average distance travelled for each customer?
--5) What was the difference between the longest and shortest delivery times for all orders?
--6) What was the average speed for each runner for each delivery and do you notice any trend for these values?
--7) What is the successful delivery percentage for each runner?

--Creating a temporary table:
DROP TABLE IF EXISTS parties_experience;
CREATE TEMP TABLE parties_experience AS
SELECT C.order_id,
    C.customer_id,
    C.pizza_id,
    R.runner_id,
    R.distance,
    R.duration,
    C.order_time,
    R.pickup_time
FROM customer_orders_cleaned AS C
    LEFT JOIN runner_orders_cleaned AS R ON C.order_id = R.order_id
WHERE R.cancellation IS NULL
ORDER BY order_id;

--1) How many runners signed up for each 1 week period? (i.e. week starts 2021-01-01)
SELECT week_signed_up,
    COUNT(week_signed_up) as runners_signed_up
FROM (
        SELECT runner_id,
            CAST(to_char(registration_date, 'WW') AS NUMERIC) AS week_signed_up
        FROM runners
    ) AS runner_sign_date
GROUP BY week_signed_up
ORDER BY week_signed_up;

--2) What was the average time in minutes it took for each runner to arrive at the Pizza Runner HQ to 
--   pickup the order?
SELECT runner_id,
    ROUND(
        CAST(
            AVG(
                (
                    DATE_PART('hour', pickup_time - order_time) * 60 + DATE_PART('minute', pickup_time - order_time)
                ) * 60 + DATE_PART('second', pickup_time - order_time)
            ) AS NUMERIC
        ),
        2
    ) AS avg_delivery_time
FROM parties_experience
GROUP BY runner_id
ORDER BY runner_id;

--3) Is there any relationship between the number of pizzas and how long the order takes to prepare?
SELECT count_pizza_ordered,
    ROUND(AVG(avg_delivery_time), 2) AS avg_preparation_time_seconds
FROM (
        SELECT order_id,
            COUNT(pizza_id) AS count_pizza_ordered,
            ROUND(
                CAST(
                    AVG(
                        (
                            DATE_PART('hour', pickup_time - order_time) * 60 + DATE_PART('minute', pickup_time - order_time)
                        ) * 60 + DATE_PART('second', pickup_time - order_time)
                    ) AS NUMERIC
                ),
                2
            ) AS avg_delivery_time
        FROM parties_experience
        GROUP BY order_id
    ) AS order_metrics
GROUP BY count_pizza_ordered
ORDER BY count_pizza_ordered;
-- The number of pizzas ordered seems to be correlated to the preparation time

--4) What was the average distance travelled for each customer?
SELECT customer_id,
    ROUND(AVG(distance), 2)
FROM parties_experience
GROUP BY customer_id
ORDER BY customer_id;

--5) What was the difference between the longest and shortest delivery times for all orders?
SELECT max_duration - min_duration AS difference_delivery_time_seconds
FROM (
        SELECT MAX(duration) AS max_duration,
            MIN(duration) AS min_duration
        FROM parties_experience
    ) AS first_layer;

--6) What was the average speed for each runner for each delivery and do you notice any trend for these values?
SELECT runner_id,
    order_id,
    ROUND(
        (distance::NUMERIC /(duration::NUMERIC / 60)),
        2
    ) AS speed,
    distance
FROM parties_experience
GROUP BY runner_id,
    order_id,
    speed,
    distance
ORDER BY runner_id,
    order_id;
-- The runners seem to increase their speed from orders to orders. However, this speed increases is not 
-- correlated to distance (which could indicates either tiredness or use of a different vehicules). We do not have enough data to produce interesting insghts yet.

--7) What is the successful delivery percentage for each runner?
--UPDATE TEMP TABLE, this time taking in account the NULL values:
DROP TABLE IF EXISTS parties_experience;
CREATE TEMP TABLE parties_experience AS
SELECT C.order_id,
    C.customer_id,
    C.pizza_id,
    R.runner_id,
    R.distance,
    R.duration,
    C.order_time,
    R.pickup_time,
    R.cancellation
FROM customer_orders_cleaned AS C
    LEFT JOIN runner_orders_cleaned AS R ON C.order_id = R.order_id
ORDER BY order_id;
SELECT runner_id,
    ROUND(
        100 * SUM(successful_orders::numeric) / COUNT(successful_orders::numeric),
        2
    ) AS percentage_successful_delivery
FROM (
        SELECT runner_id,
            order_id,
            CASE
                WHEN cancellation IS NOT NULL then 0
                ELSE 1
            END AS successful_orders
        FROM parties_experience
        GROUP BY runner_id,
            order_id,
            cancellation
        ORDER BY runner_id,
            order_id
    ) as first_layer
GROUP BY runner_id;

-------------------------------------------------------
--PART 3: Ingredient Optimisation ! 
--Questions:
-- 1) What are the standard ingredients for each pizza?
-- 2) What was the most commonly added extra?
-- 3) What was the most common exclusion?
-- 4) Generate an order item for each record in the customers_orders table in the format of one of the following:
--     Meat Lovers
--     Meat Lovers - Exclude Beef
--     Meat Lovers - Extra Bacon
--     Meat Lovers - Exclude Cheese, Bacon - Extra Mushroom, Peppers
-- 5) Generate an alphabetically ordered comma separated ingredient list for each pizza order from the customer_orders table and add a 2x in front of any relevant ingredients
--     For example: "Meat Lovers: 2xBacon, Beef, ... , Salami"
-- 6) What is the total quantity of each ingredient used in all delivered pizzas sorted by most frequent first?

-- 1) What are the standard ingredients for each pizza?
WITH pizza_recipes_unstacked AS (
    SELECT pizza_id,
        CAST(
            UNNEST(
                string_to_array(toppings, ', ')
            ) AS INT
        ) AS topping_id
    FROM pizza_recipes
)
SELECT t1.pizza_id,
    t1.pizza_name,
    t2.topping_id,
    t3.topping_name
FROM pizza_names t1
    JOIN pizza_recipes_unstacked t2 ON t1.pizza_id = t2.pizza_id
    JOIN pizza_toppings t3 ON t2.topping_id = t3.topping_id
ORDER BY t1.pizza_id,
    t2.topping_id;

--2) What was the most commonly added extra?
SELECT extras,
    topping_name,
    COUNT(extras) AS times_ordered
FROM (
        SELECT order_id,
            CAST(
                UNNEST(string_to_array(extras, ', ')) AS INT
            ) AS extras
        FROM customer_orders_cleaned
    ) AS extras_information
    JOIN pizza_toppings ON pizza_toppings.topping_id = extras_information.extras
GROUP BY extras,
    topping_name
ORDER BY times_ordered DESC;

-- 3) What was the most common exclusion?
SELECT exclusions,
    topping_name,
    COUNT(exclusions) AS times_ordered
FROM (
        SELECT order_id,
            CAST(
                UNNEST(string_to_array(exclusions, ', ')) AS INT
            ) AS exclusions
        FROM customer_orders_cleaned
    ) AS exclusions_information
    JOIN pizza_toppings ON pizza_toppings.topping_id = exclusions_information.exclusions
GROUP BY exclusions,
    topping_name
ORDER BY times_ordered DESC;

-- 4) Generate an order item for each record in the customers_orders table in the format of one of the following:
--     Meat Lovers
--     Meat Lovers - Exclude Beef
--     Meat Lovers - Extra Bacon
--     Meat Lovers - Exclude Cheese, Bacon - Extra Mushroom, Peppers
DROP VIEW IF EXISTS extras_exclusions;
CREATE VIEW extras_exclusions AS
SELECT order_id,
    customers_info.pizza_id,
    pizza_names.pizza_name,
    exclusion_col1,
    top1.topping_name AS topping_name1,
    CASE
        WHEN exclusion_col2 = '' THEN NULL
        ELSE TRIM(exclusion_col2)::INTEGER
    END as exclusion_col2,
    extras_col1,
    top2.topping_name AS topping_name3,
    CASE
        WHEN extras_col2 = '' THEN NULL
        ELSE TRIM(extras_col2)::INTEGER
    END as extras_col2
FROM (
        SELECT order_id,
            pizza_id,
            split_part(exclusions, ',', 1) AS exclusion_col1,
            -- I could have unstacked the columns too as a solution, but I wanted to practice a different solution 
            split_part(exclusions, ',', 2) AS exclusion_col2,
            -- I use the unstacking method in the next question
            split_part(extras, ',', 1) AS extras_col1,
            split_part(extras, ',', 2) AS extras_col2
        FROM customer_orders_cleaned
        ORDER BY order_id
    ) AS customers_info
    JOIN pizza_names ON customers_info.pizza_id = pizza_names.pizza_id
    LEFT JOIN pizza_toppings top1 ON customers_info.exclusion_col1::INT = top1.topping_id
    LEFT JOIN pizza_toppings top2 ON customers_info.extras_col1::INT = top2.topping_id;
    -- LEFT JOIN pizza_toppings top2 ON customers_info.exclusion_col2::INT = top2.topping_id = > exclusion2 is considered as text (even if I use coalesce::INT and so on..)

SELECT order_id,
    CONCAT(pizza_name, ' ', exclusions, ' ', extras) AS pizza_details
FROM (
        WITH tabular_modifications AS(
            SELECT order_id,
                pizza_id,
                pizza_name,
                exclusion_col1,
                topping_name1,
                exclusion_col2::INT,
                t2.topping_name AS topping_name2,
                extras_col1,
                topping_name3,
                extras_col2::INT,
                t3.topping_name AS topping_name4
            FROM extras_exclusions t1
                LEFT JOIN pizza_toppings t2 ON t1.exclusion_col2 = t2.topping_id
                LEFT JOIN pizza_toppings t3 ON t1.extras_col2 = t3.topping_id
        )
        SELECT order_id,
            pizza_id,
            pizza_name,
            CASE
                WHEN exclusion_col1 IS NULL THEN CONCAT(topping_name1, ' ', topping_name2)
                WHEN exclusion_col2 IS NULL THEN CONCAT('- Exclude', ' ', topping_name1)
                ELSE CONCAT(
                    '- Exclude',
                    ' ',
                    topping_name1,
                    ', ',
                    topping_name2
                )
            END AS exclusions,
            CASE
                WHEN extras_col1 IS NULL THEN CONCAT(topping_name3, ' ', topping_name4)
                WHEN extras_col2 IS NULL THEN CONCAT('- Extra', ' ', topping_name3)
                ELSE CONCAT(
                    '- Extra',
                    ' ',
                    topping_name3,
                    ', ',
                    topping_name4
                )
            END AS extras
        FROM tabular_modifications
    ) AS Modified_concat
ORDER BY order_id;

-- 5) Generate an alphabetically ordered comma separated ingredient list for each pizza order from the customer_orders table and add a 2x in front of any relevant ingredients
--     For example: "Meat Lovers: 2xBacon, Beef, ... , Salami"

-- Step 1: create basic recipe table (recycling question 1)
DROP TABLE IF EXISTS classical_recipe;
CREATE TEMP TABLE classical_recipe AS WITH pizza_recipes_unstacked AS (
    SELECT pizza_id,
        CAST(
            UNNEST(
                string_to_array(toppings, ', ')
            ) AS INT
        ) AS topping_id
    FROM pizza_recipes
)
SELECT t4.row_number_order,
    t4.order_id,
    t4.customer_id,
    t1.pizza_id,
    t1.pizza_name,
    t2.topping_id,
    t3.topping_name
FROM pizza_names t1
    JOIN pizza_recipes_unstacked t2 ON t1.pizza_id = t2.pizza_id
    JOIN pizza_toppings t3 ON t2.topping_id = t3.topping_id
    RIGHT JOIN customer_orders_cleaned t4 ON t1.pizza_id = t4.pizza_id;

-- Step 2: unpivot extras and exclusions table into 2 separated table:
DROP TABLE IF EXISTS orders_exclusions;
CREATE TEMP TABLE orders_exclusions AS
SELECT row_number_order,
    order_id,
    customer_id,
    customer_orders_cleaned.pizza_id,
    pizza_name,
    --exclusions,
    CAST(
        UNNEST(string_to_array(COALESCE(exclusions, '0'), ',')) AS INT
    ) AS exclusions --extras,
    --CAST(UNNEST(string_to_array(COALESCE(extras, '0'), ',')) AS INT) AS extras,
FROM customer_orders_cleaned
    JOIN pizza_names ON customer_orders_cleaned.pizza_id = pizza_names.pizza_id
ORDER BY order_id;
DROP TABLE IF EXISTS orders_extras;
CREATE TEMP TABLE orders_extras AS
SELECT row_number_order,
    order_id,
    customer_id,
    customer_orders_cleaned.pizza_id,
    pizza_name,
    --exclusions,
    --CAST(UNNEST(string_to_array(COALESCE(exclusions, '0'), ',')) AS INT) AS exclusions
    --extras,
    CAST(
        UNNEST(string_to_array(COALESCE(extras, '0'), ',')) AS INT
    ) AS extras
FROM customer_orders_cleaned
    JOIN pizza_names ON customer_orders_cleaned.pizza_id = pizza_names.pizza_id
ORDER BY order_id;

--step 3: Join all the tables (Union extras, Except exclusions):
DROP TABLE IF EXISTS pizzas_details;
CREATE TEMP TABLE pizzas_details AS WITH first_layer AS (
    SELECT row_number_order,
        order_id,
        customer_id,
        pizza_id,
        pizza_name,
        topping_id
    FROM classical_recipe
    EXCEPT
    SELECT *
    FROM orders_exclusions
    UNION ALL
    -- No duplicates
    SELECT *
    FROM orders_extras
    WHERE extras != 0
)
SELECT row_number_order,
    order_id,
    customer_id,
    -- I kept it because it would be interesting to see preferences as bonus analytic
    pizza_id,
    pizza_name,
    first_layer.topping_id,
    topping_name
FROM first_layer
    LEFT JOIN pizza_toppings ON first_layer.topping_id = pizza_toppings.topping_id
ORDER BY row_number_order,
    order_id,
    pizza_id,
    topping_id;

-- Step 4: let's  now reshape the data to answer the question
WITH counting_table AS(
    --Count how many times each ingredient is used
    SELECT row_number_order,
        order_id,
        customer_id pizza_id,
        pizza_name,
        topping_id,
        topping_name,
        COUNT(topping_id) AS count_ingredient
    FROM pizzas_details
    GROUP BY row_number_order,
        order_id,
        customer_id,
        pizza_id,
        pizza_name,
        topping_id,
        topping_name
),
text_table AS(
    --Create the basic text for each ingredient
    SELECT row_number_order,
        order_id,
        pizza_id,
        pizza_name,
        topping_id,
        CASE
            WHEN count_ingredient = 1 THEN topping_name
            ELSE CONCAT(count_ingredient, 'x ', topping_name)
        END AS ingredient_count
    FROM counting_table
),
group_text AS(
    --Concatenate all texts per pizza
    SELECT row_number_order,
        order_id,
        pizza_id,
        pizza_name,
        STRING_AGG(ingredient_count, ', ') AS recipe
    FROM text_table
    GROUP BY row_number_order,
        order_id,
        pizza_id,
        pizza_name
)
SELECT row_number_order,
    order_id,
    CONCAT(pizza_name, ': ', recipe)
FROM group_text
ORDER BY row_number_order,
    order_id;

-- 6) What is the total quantity of each ingredient used in all delivered pizzas sorted by most frequent first?
SELECT topping_id,
    topping_name,
    COUNT(topping_id) as time_used
FROM pizzas_details
GROUP BY topping_id,
    topping_name
ORDER BY time_used DESC;

-------------------------------------------------------
--PART 4: Pricing and Ratings ! 
--Questions:
-- 1) If a Meat Lovers pizza costs $12 and Vegetarian costs $10 and there were no charges for changes - how much money has Pizza Runner
--    made so far if there are no delivery fees?
-- 2) What if there was an additional $1 charge for any pizza extras?
-- - Add cheese is $1 extra
-- 3) What if substitutes were allowed at no additional cost but any additional extras were charged at $1?
-- - Exclude Cheese and add Bacon is free
-- - Exclude Cheese but add bacon and beef costs $1 extra
-- 4) What if meat substitutes and vegetable substitutes were allowed but any change outside were charged at $2 and $1 respectively?
-- - Exclude Cheese and add Bacon is $2 extra
-- - Exclude Beef and add mushroom is $1 extra
-- - Exclude Beef and add Bacon is free
-- - Exclude Beef and Mushroom, and add Bacon and Cheese is free
-- 5)The Pizza Runner team now wants to add an additional ratings system that allows customers to rate their runner, 
--   how would you design an additional table for this new dataset - generate a schema for this new table and insert 
--   your own data for ratings for each successful customer order between 1 to 5.
-- 6)Using your newly generated table - can you join all of the information together to form a table which has the following information for successful deliveries?
-- - customer_id
-- - order_id
-- - runner_id
-- - rating
-- - order_time
-- - pickup_time
-- - Time between order and pickup
-- - Delivery duration
-- - Average speed
-- - Total number of pizzas
-- 7) If a Meat Lovers pizza was $12 and Vegetarian $10 fixed prices with no cost for extras and each runner is paid $0.30 per kilometre
--    traveled - how much money does Pizza Runner have left over after these deliveries?
-- 8) If 1 unit of each ingredient costs $0.50 - how much net revenue will Pizza Runner make if the costs from question 30 are used?

-- 1) If a Meat Lovers pizza costs $12 and Vegetarian costs $10 and there were no charges for changes - how much money has Pizza Runner
--    made so far if there are no delivery fees?

--Let's create a temp table to make this more organized. I do not append those information to existing tables as it would require discussion
-- with the person managing the database (in a real situation). I'll use another method.
DROP TABLE IF EXISTS pizza_prices;
CREATE TEMP TABLE pizza_prices ("pizza_id" INTEGER, "price" INTEGER);
INSERT INTO pizza_prices ("pizza_id", "price")
VALUES (1, 12),
    (2, 10);
WITH profit_table AS (
    SELECT C.pizza_id,
        COUNT(C.pizza_id) * price as pizza_revenues
    FROM customer_orders_cleaned AS C
        LEFT JOIN runner_orders_cleaned AS R ON C.order_id = R.order_id
        LEFT JOIN pizza_prices AS P ON C.pizza_id = P.pizza_id
    WHERE R.cancellation IS NULL
    GROUP BY C.pizza_id,
        price
)
SELECT SUM(pizza_revenues) AS total_revenue
FROM profit_table;

-- 2) What if there was an additional $1 charge for any pizza extras?
-- - Add cheese is $1 extra

-- let's recycle last part queries:
DROP TABLE IF EXISTS orders_extras;
CREATE TEMP TABLE orders_extras AS
SELECT row_number_order,
    order_id,
    customer_id,
    customer_orders_cleaned.pizza_id,
    pizza_name,
    CAST(
        UNNEST(string_to_array(COALESCE(extras, '0'), ',')) AS INT
    ) AS extras
FROM customer_orders_cleaned
    JOIN pizza_names ON customer_orders_cleaned.pizza_id = pizza_names.pizza_id
ORDER BY order_id;
WITH segmented_revenues AS (
    SELECT table1.pizza_id,
        table1.pizza_revenues,
        table2.extras_revenues,
        (table1.pizza_revenues + table2.extras_revenues) AS total_revenues
    FROM (
            SELECT C.pizza_id,
                COUNT(C.pizza_id) * price as pizza_revenues
            FROM customer_orders_cleaned AS C
                LEFT JOIN runner_orders_cleaned AS R ON C.order_id = R.order_id
                LEFT JOIN pizza_prices AS P ON C.pizza_id = P.pizza_id
            WHERE R.cancellation IS NULL
            GROUP BY C.pizza_id,
                price
        ) AS table1
        LEFT JOIN (
            SELECT t1.pizza_id,
                SUM(
                    CASE
                        WHEN t1.extras > 0 THEN 1
                        ELSE 0
                    END
                ) AS extras_revenues
            FROM orders_extras t1
                LEFT JOIN pizza_prices t2 ON t1.pizza_id = t2.pizza_id
                LEFT JOIN runner_orders_cleaned t3 ON t1.order_id = t3.order_id
            WHERE t3.cancellation IS NULL
            GROUP BY t1.pizza_id
        ) AS table2 ON table1.pizza_id = table2.pizza_id
)
SELECT SUM(total_revenues) AS total_revenues
FROM segmented_revenues;

-- 3) What if substitutes were allowed at no additional cost but any additional extras were charged at $1?
-- - Exclude Cheese and add Bacon is free
-- - Exclude Cheese but add bacon and beef costs $1 extra

-- Step 1: create an unstacked table with the extras and exceptions 
DROP TABLE IF EXISTS exclusions_extras_unstacked;
CREATE TEMP TABLE exclusions_extras_unstacked AS
SELECT row_number_order,
    order_id,
    customer_id,
    customer_orders_cleaned.pizza_id,
    pizza_name,
    CAST(
        UNNEST(string_to_array(COALESCE(exclusions, '0'), ',')) AS INT
    ) AS exclusions,
    CAST(
        UNNEST(string_to_array(COALESCE(extras, '0'), ',')) AS INT
    ) AS extras
FROM customer_orders_cleaned
    JOIN pizza_names ON customer_orders_cleaned.pizza_id = pizza_names.pizza_id
ORDER BY order_id;

--Step 2: create a balance to see if we had more extras than exclusions
WITH order_layer AS (
    SELECT row_number_order,
        order_id,
        pizza_id,
        SUM(
            CASE
                WHEN extras > 0 THEN 1
                ELSE 0
            END
        ) - SUM(
            CASE
                WHEN exclusions > 0 THEN 1
                ELSE 0
            END
        ) AS substitutes_cost
    FROM exclusions_extras_unstacked
    GROUP BY row_number_order,
        order_id,
        pizza_id
),
pizza_layer AS(
    SELECT row_number_order,
        order_id,
        pizza_id,
        CASE
            WHEN substitutes_cost < 0 THEN 0
            ELSE substitutes_cost
        END AS substitutes_cost
    FROM order_layer
)
SELECT pizza_id,
    SUM(substitutes_cost) AS substitutes_cost
FROM pizza_layer
GROUP BY pizza_id;

--Step 3: Change the LEFT JOIN in our last question query with the one created in step 2.
WITH segmented_revenues AS (
    SELECT table1.pizza_id,
        table1.pizza_revenues,
        table2.substitutes_cost,
        (table1.pizza_revenues + table2.substitutes_cost) AS total_revenues
    FROM (
            SELECT C.pizza_id,
                COUNT(C.pizza_id) * price as pizza_revenues
            FROM customer_orders_cleaned AS C
                LEFT JOIN runner_orders_cleaned AS R ON C.order_id = R.order_id
                LEFT JOIN pizza_prices AS P ON C.pizza_id = P.pizza_id
            WHERE R.cancellation IS NULL
            GROUP BY C.pizza_id,
                price
        ) AS table1
        LEFT JOIN (
            WITH order_layer AS (
                SELECT row_number_order,
                    order_id,
                    pizza_id,
                    SUM(
                        CASE
                            WHEN extras > 0 THEN 1
                            ELSE 0
                        END
                    ) - SUM(
                        CASE
                            WHEN exclusions > 0 THEN 1
                            ELSE 0
                        END
                    ) AS substitutes_cost
                FROM exclusions_extras_unstacked
                GROUP BY row_number_order,
                    order_id,
                    pizza_id
            ),
            pizza_layer AS(
                SELECT row_number_order,
                    order_id,
                    pizza_id,
                    CASE
                        WHEN substitutes_cost < 0 THEN 0
                        ELSE substitutes_cost
                    END AS substitutes_cost
                FROM order_layer
            )
            SELECT pizza_id,
                SUM(substitutes_cost) AS substitutes_cost
            FROM pizza_layer
            GROUP BY pizza_id
        ) AS table2 ON table1.pizza_id = table2.pizza_id
)
SELECT SUM(total_revenues) AS total_revenues
FROM segmented_revenues;

-- 4) What if meat substitutes and vegetable substitutes were allowed but any change outside were charged at $2 and $1 respectively?
-- - Exclude Cheese and add Bacon is $2 extra
-- - Exclude Beef and add mushroom is $1 extra
-- - Exclude Beef and add Bacon is free
-- - Exclude Beef and Mushroom, and add Bacon and Cheese is free

-- Table 2: Just as before, we will not modify existing tables.
DROP TABLE IF EXISTS modification_prices;
CREATE TEMP TABLE modification_prices (
    "topping_id" INTEGER,
    "topping_name" TEXT,
    "type" INTEGER,
    "type_name" TEXT,
    "modification_price" INTEGER
);
INSERT INTO modification_prices (
        "topping_id",
        "topping_name",
        "type",
        "type_name",
        "modification_price"
    )
VALUES ('1', 'Bacon', '1', 'Vegetable', '2'),
    ('2', 'BBQ Sauce', '0', 'Sauce', '0'),
    ('3', 'Beef', '1', 'Meat', '2'),
    ('4', 'Cheese', '2', 'Vegetable', '1'),
    ('5', 'Chicken', '1', 'Meat', '2'),
    ('6', 'Mushrooms', '2', 'Vegetable', '1'),
    ('7', 'Onions', '2', 'Vegetable', '1'),
    ('8', 'Pepperoni', '1', 'Meat', '2'),
    ('9', 'Peppers', '2', 'Vegetable', '1'),
    ('10', 'Salami', '1', 'Meat', '2'),
    ('11', 'Tomatoes', '2', 'Vegetable', '1'),
    ('12', 'Tomato Sauce', '0', 'Sauce', '0');
------------------------------------------ 
WITH unstacking AS(
    SELECT t1.row_number_order,
        t1.order_id,
        t1.pizza_id,
        t1.exclusions,
        t1.extras,
        t2.type AS exclusion_type,
        t3.type AS extras_type,
        t3.modification_price AS extras_price
    FROM exclusions_extras_unstacked t1
        LEFT JOIN modification_prices t2 ON t1.exclusions = t2.topping_id
        LEFT JOIN modification_prices t3 ON t1.extras = t3.topping_id
    ORDER BY order_id
),
condition_type AS(
    SELECT row_number_order,
        order_id,
        pizza_id,
        extras_price,
        CASE
            WHEN exclusion_type = 1 THEN 1
            ELSE 0
        END AS exclusion_type1,
        CASE
            WHEN exclusion_type = 2 THEN 1
            ELSE 0
        END AS exclusion_type2,
        CASE
            WHEN extras_type = 1 THEN 1
            ELSE 0
        END AS extras_type1,
        CASE
            WHEN extras_type = 2 THEN 1
            ELSE 0
        END AS extras_type2
    FROM unstacking
),
count_type AS(
    SELECT row_number_order,
        order_id,
        pizza_id,
        extras_price,
        SUM(exclusion_type1) AS exclusion_type1,
        SUM(exclusion_type2) AS exclusion_type2,
        SUM(extras_type1) AS extras_type1,
        SUM(extras_type2) AS extras_type2
    FROM condition_type
    GROUP BY row_number_order,
        order_id,
        pizza_id,
        extras_price
    ORDER BY row_number_order
),
fees_type AS(
    SELECT row_number_order,
        order_id,
        pizza_id,
        CASE
            WHEN (extras_type1 - exclusion_type1) * extras_price < 0 THEN 0
            ELSE (extras_type1 - exclusion_type1) * extras_price
        END AS fees_type1,
        CASE
            WHEN (extras_type2 - exclusion_type2) * extras_price < 0 THEN 0
            ELSE (extras_type2 - exclusion_type2) * extras_price
        END AS fees_type2
    FROM count_type
)
SELECT pizza_id,
    SUM(fees_type1) + SUM(fees_type2) AS substitutes_cost
FROM fees_type
GROUP BY pizza_id;

--Step 3: Compute the total revenues with the previously used queries:
WITH segmented_revenues AS (
    SELECT table1.pizza_id,
        table1.pizza_revenues,
        table2.substitutes_cost,
        (table1.pizza_revenues + table2.substitutes_cost) AS total_revenues
    FROM (
            SELECT C.pizza_id,
                COUNT(C.pizza_id) * price as pizza_revenues
            FROM customer_orders_cleaned AS C
                LEFT JOIN runner_orders_cleaned AS R ON C.order_id = R.order_id
                LEFT JOIN pizza_prices AS P ON C.pizza_id = P.pizza_id
            WHERE R.cancellation IS NULL
            GROUP BY C.pizza_id,
                price
        ) AS table1
        LEFT JOIN (
            WITH unstacking AS(
                SELECT t1.row_number_order,
                    t1.order_id,
                    t1.pizza_id,
                    t1.exclusions,
                    t1.extras,
                    t2.type AS exclusion_type,
                    t3.type AS extras_type,
                    t3.modification_price AS extras_price
                FROM exclusions_extras_unstacked t1
                    LEFT JOIN modification_prices t2 ON t1.exclusions = t2.topping_id
                    LEFT JOIN modification_prices t3 ON t1.extras = t3.topping_id
                ORDER BY order_id
            ),
            condition_type AS(
                SELECT row_number_order,
                    order_id,
                    pizza_id,
                    extras_price,
                    CASE
                        WHEN exclusion_type = 1 THEN 1
                        ELSE 0
                    END AS exclusion_type1,
                    CASE
                        WHEN exclusion_type = 2 THEN 1
                        ELSE 0
                    END AS exclusion_type2,
                    CASE
                        WHEN extras_type = 1 THEN 1
                        ELSE 0
                    END AS extras_type1,
                    CASE
                        WHEN extras_type = 2 THEN 1
                        ELSE 0
                    END AS extras_type2
                FROM unstacking
            ),
            count_type AS(
                SELECT row_number_order,
                    order_id,
                    pizza_id,
                    extras_price,
                    SUM(exclusion_type1) AS exclusion_type1,
                    SUM(exclusion_type2) AS exclusion_type2,
                    SUM(extras_type1) AS extras_type1,
                    SUM(extras_type2) AS extras_type2
                FROM condition_type
                GROUP BY row_number_order,
                    order_id,
                    pizza_id,
                    extras_price
                ORDER BY row_number_order
            ),
            fees_type AS(
                SELECT row_number_order,
                    order_id,
                    pizza_id,
                    CASE
                        WHEN (extras_type1 - exclusion_type1) * extras_price < 0 THEN 0
                        ELSE (extras_type1 - exclusion_type1) * extras_price
                    END AS fees_type1,
                    CASE
                        WHEN (extras_type2 - exclusion_type2) * extras_price < 0 THEN 0
                        ELSE (extras_type2 - exclusion_type2) * extras_price
                    END AS fees_type2
                FROM count_type
            )
            SELECT pizza_id,
                SUM(fees_type1) + SUM(fees_type2) AS substitutes_cost
            FROM fees_type
            GROUP BY pizza_id
        ) AS table2 ON table1.pizza_id = table2.pizza_id
)
SELECT SUM(total_revenues) AS total_revenues
FROM segmented_revenues;

-- 5)The Pizza Runner team now wants to add an additional ratings system that allows customers to rate their runner, 
--   how would you design an additional table for this new dataset - generate a schema for this new table and insert 
--   your own data for ratings for each successful customer order between 1 to 5.
DROP TABLE IF EXISTS runner_ratings;
CREATE TABLE runner_ratings (
    "order_id" INTEGER,
    "rating" INTEGER CONSTRAINT check1to5_rating CHECK (
        "rating" between 1 and 5
    ),
    "comment" VARCHAR(150)
);
INSERT INTO runner_ratings ("order_id", "rating", "comment")
VALUES ('1', '2', 'Tasty'),
    ('2', '4', ''),
    ('3', '4', ''),
    (
        '4',
        '5',
        'The pizza arrived cold, really bad service'
    ),
    ('5', '2', ''),
    ('6', NULL, ''),
    ('7', '5', ''),
    ('8', '4', 'Great service'),
    ('9', NULL, ''),
    (
        '10',
        '1',
        'The pizza arrived upside down, really disappointed'
    );
SELECT *
FROM runner_ratings;

-- 6)Using your newly generated table - can you join all of the information together to form a table which has the following information for successful deliveries?
-- - customer_id
-- - order_id
-- - runner_id
-- - rating
-- - order_time
-- - pickup_time
-- - Time between order and pickup
-- - Delivery duration
-- - Average speed
-- - Total number of pizzas

DROP TABLE IF EXISTS Global_table;
CREATE TEMP TABLE Global_table AS WITH runner_layer1 AS (
    SELECT order_id,
        runner_id,
        CAST(
            CASE
                WHEN pickup_time = 'null' THEN NULL
                ELSE pickup_time
            END AS timestamp
        ) AS pickup_time,
        CASE
            WHEN distance = '' THEN NULL
            WHEN distance = 'null' THEN NULL
            ELSE distance
        END as distance,
        CASE
            WHEN duration = '' THEN NULL
            WHEN duration = 'null' THEN NULL
            ELSE duration
        END as duration,
        CASE
            WHEN cancellation = '' THEN NULL
            WHEN cancellation = 'null' THEN NULL
            ELSE cancellation
        END as cancellation
    FROM runner_orders
),
runner_layer2 AS(
    SELECT order_id,
        runner_id,
        CASE
            WHEN order_id = '3' THEN (pickup_time + INTERVAL '13 hour')
            ELSE pickup_time
        END AS pickup_time,
        CAST(
            regexp_replace(distance, '[a-z]+', '') AS DECIMAL(5, 2)
        ) AS distance,
        CAST(regexp_replace(duration, '[a-z]+', '') AS INT) AS duration,
        cancellation
    FROM runner_layer1
)
SELECT t1.order_id,
    t2.customer_id,
    t1.runner_id,
    t3.rating,
    t2.order_time,
    t1.pickup_time,
    (
        DATE_PART('hour', t1.pickup_time - t2.order_time) * 60 + DATE_PART('minute', t1.pickup_time - t2.order_time)
    ) * 60 + DATE_PART('second', t1.pickup_time - t2.order_time) AS time_between_order_and_pickup,
    t1.distance,
    t1.duration,
    ROUND(
        (
            t1.distance::NUMERIC /(t1.duration::NUMERIC / 60)
        ),
        2
    ) AS average_speed,
    COUNT(t2.pizza_id) AS count_pizza
FROM runner_layer2 t1
    LEFT JOIN customer_orders t2 ON t1.order_id = t2.order_id
    LEFT JOIN runner_ratings t3 ON t1.order_id = t3.order_id
WHERE cancellation IS NULL
GROUP BY t1.order_id,
    t1.runner_id,
    t1.pickup_time,
    t1.distance,
    t1.duration,
    ROUND(
        (
            t1.distance::NUMERIC /(t1.duration::NUMERIC / 60)
        ),
        2
    ),
    t2.customer_id,
    t2.order_time,
    t3.rating;

SELECT *
FROM Global_table; 

-- 7) If a Meat Lovers pizza was $12 and Vegetarian $10 fixed prices with no cost for extras and each runner is paid $0.30 per kilometre
    --    traveled - how much money does Pizza Runner have left over after these deliveries?
    WITH pizza_revenues AS(
        SELECT t1.order_id,
            pizza_id,
            CASE
                WHEN pizza_id = 1 THEN COUNT(pizza_id) * 12
                ELSE COUNT(pizza_id) * 10
            END AS pizza_revenues
        FROM customer_orders_cleaned t1
            LEFT JOIN runner_orders_cleaned t2 ON t1.order_id = t2.order_id
        WHERE cancellation IS NULL
        GROUP BY t1.order_id,
            pizza_id
    ),
    revenues_delivery AS(
        SELECT t1.order_id,
            t2.distance * 0.3 AS delivery_cost,
            SUM(t1.pizza_revenues) AS order_revenues
        FROM pizza_revenues t1
            LEFT JOIN Global_table t2 ON t1.order_id = t2.order_id
        GROUP BY t1.order_id,
            distance
    )
SELECT ROUND(SUM(order_revenues) - SUM(delivery_COST), 2) AS revenues_afterdelivery
FROM revenues_delivery;

-- 8) If 1 unit of each ingredient costs $0.50 - how much net revenue will Pizza Runner make if the costs from question 30 are used?
--Let's go back to previous queries where we obtained how many times each ingredients were used (question 5 & 6 of part Ingredient Optimization)
DROP TABLE IF EXISTS classical_recipe;
CREATE TEMP TABLE classical_recipe AS WITH pizza_recipes_unstacked AS (
    SELECT pizza_id,
        CAST(
            UNNEST(
                string_to_array(toppings, ', ')
            ) AS INT
        ) AS topping_id
    FROM pizza_recipes
)
SELECT t4.row_number_order,
    t4.order_id,
    t4.customer_id,
    t1.pizza_id,
    t1.pizza_name,
    t2.topping_id,
    t3.topping_name
FROM pizza_names t1
    JOIN pizza_recipes_unstacked t2 ON t1.pizza_id = t2.pizza_id
    JOIN pizza_toppings t3 ON t2.topping_id = t3.topping_id
    RIGHT JOIN customer_orders_cleaned t4 ON t1.pizza_id = t4.pizza_id;
DROP TABLE IF EXISTS orders_exclusions;
CREATE TEMP TABLE orders_exclusions AS
SELECT row_number_order,
    order_id,
    customer_id,
    customer_orders_cleaned.pizza_id,
    pizza_name,
    --exclusions,
    CAST(
        UNNEST(string_to_array(COALESCE(exclusions, '0'), ',')) AS INT
    ) AS exclusions --extras,
    --CAST(UNNEST(string_to_array(COALESCE(extras, '0'), ',')) AS INT) AS extras,
FROM customer_orders_cleaned
    JOIN pizza_names ON customer_orders_cleaned.pizza_id = pizza_names.pizza_id
ORDER BY order_id;
DROP TABLE IF EXISTS orders_extras;
CREATE TEMP TABLE orders_extras AS
SELECT row_number_order,
    order_id,
    customer_id,
    customer_orders_cleaned.pizza_id,
    pizza_name,
    --exclusions,
    --CAST(UNNEST(string_to_array(COALESCE(exclusions, '0'), ',')) AS INT) AS exclusions
    --extras,
    CAST(
        UNNEST(string_to_array(COALESCE(extras, '0'), ',')) AS INT
    ) AS extras
FROM customer_orders_cleaned
    JOIN pizza_names ON customer_orders_cleaned.pizza_id = pizza_names.pizza_id
ORDER BY order_id;

--step 3: Join all the tables (Union extras, Except exclusions):
DROP TABLE IF EXISTS pizzas_details;
CREATE TEMP TABLE pizzas_details AS WITH first_layer AS (
    SELECT row_number_order,
        order_id,
        customer_id,
        pizza_id,
        pizza_name,
        topping_id
    FROM classical_recipe
    EXCEPT
    SELECT *
    FROM orders_exclusions
    UNION ALL
    -- No duplicates
    SELECT *
    FROM orders_extras
    WHERE extras != 0
)
SELECT row_number_order,
    order_id,
    customer_id,
    -- I kept it because it would be interesting to see preferences as bonus analytic
    pizza_id,
    pizza_name,
    first_layer.topping_id,
    topping_name
FROM first_layer
    LEFT JOIN pizza_toppings ON first_layer.topping_id = pizza_toppings.topping_id
ORDER BY row_number_order,
    order_id,
    pizza_id,
    topping_id;

--Detail of the query to get the ingredients' cost per order_id
SELECT order_id,
    COUNT(topping_id) * 0.5 as ingredient_costs
FROM pizzas_details
GROUP BY order_id
ORDER BY order_id;

--Now let's fill this in the query of the previous question:
WITH pizza_revenues AS(
    SELECT t1.order_id,
        pizza_id,
        CASE
            WHEN pizza_id = 1 THEN COUNT(pizza_id) * 12
            ELSE COUNT(pizza_id) * 10
        END AS pizza_revenues
    FROM customer_orders_cleaned t1
        LEFT JOIN runner_orders_cleaned t2 ON t1.order_id = t2.order_id
    WHERE cancellation IS NULL
    GROUP BY t1.order_id,
        pizza_id
),
revenues_delivery AS(
    SELECT t1.order_id,
        t2.distance * 0.3 AS delivery_cost,
        SUM(t1.pizza_revenues) AS order_revenues,
        t3.ingredient_costs
    FROM pizza_revenues t1
        LEFT JOIN Global_table t2 ON t1.order_id = t2.order_id
        LEFT JOIN (
            SELECT order_id,
                COUNT(topping_id) * 0.5 as ingredient_costs
            FROM pizzas_details
            GROUP BY order_id
        ) AS t3 ON t1.order_id = t3.order_id
    GROUP BY t1.order_id,
        distance,
        t3.ingredient_costs
)
SELECT ROUND(
        SUM(order_revenues) - SUM(delivery_COST) - SUM(ingredient_costs),
        2
    ) AS revenues_left
FROM revenues_delivery;
